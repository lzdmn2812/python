# numbers = [1, 2, 3, 8, 15, 23, 38]
# res = []
# for i in numbers:
#     if i%2==0:
#         res.append((i, i**2))
# print(res)

# def select(f, col):
#     return [f(x) for x in col] 

# def where(f, col):
#     return [x for x in col if f(x)]

# numbers = [1, 2, 3, 8, 15, 23, 38]
# res = select(int, numbers)
# res = where(lambda x: x%2 == 0, res)
# print(res)
# res = list(select(lambda x: (x, x**2), res))
# print(res)

# //////////////////////////////////////////////////

# list_1 = [x for x in range(1, 20)]
# print(list_1)

# list_1 = list(map(lambda x: x+10, list_1))
# print(list_1)

# С клавиатуры вводится некий набор чисел, в качестве 
# разделителя используется пробел. Этот набор чисел
# будет считан в качестве строки. Как превратить 
# list строк в list чисел?

# data = '15 156 96 3 5 8 52 5'

# data = list(map(int, data.split())) #лист- превращает в лист, 
# # мэп- принимает на вход функцию инт, которая преобразовывет
# # цифры строки в интовые значения, а дата.сплит передает значения
# # разделенные пробелами (но они все еще строчные)
# print(data)

# //////////////////////////////////////////////////
"""
Функция filter
"""
# data = [15, 65, 9, 36, 175]
# res = list(filter(lambda x: x%10==5, data)) #лямбда берет только те элементы
# # которые заканчиваются на 5, туда же отдаем дата- лист, откуда берем элементы
# print(res)
"""
Функция zip
применяется к набору итерируемых объектов и возвращает 
итератор с КОРТЕЖАМИ из элементов входных данных
zip ([1, 2, 3], ['o', 'д', 'т'], ['f', 's', 't']) лист списков
-> [(1, 'o', 'f'), (2, 'д', 's'), (3, 'т', 't')] список кортежей
в 1ом кортеже все первые эл-ты, во 2ом - все вторые, в 3м - все третьи эл-ты

Примеры:
users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
data = list(zip(users, ids))
print(data) -> [('user1', 4), ('user2', 5), ('user3', 9), ('user4', 14), ('user5', 7)]

Функция zip() пробегает по минимальному входящему набору

users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
salary = [111, 222, 333]
data = list(zip(users, ids, salary))
print(data) -> [('user1', 4, 111), ('user2', 5, 222), ('user3', 9, 333)
"""
# ////////////////////////////////////////////////
"""
Функция enumerate() применяется к итерируемому объекту и возвращает
список с кортежами из индекса и элементов входных данных

enumerate(['Казань', 'Смоленск', 'Рыбки', 'Чикаго'])
-> [(0, 'Казань'), (1, 'Смоленск'), (2, 'Рыбки'), (3, 'Чикаго')]

Функция позволяет пронумеровать набор данных

users = ['user1', 'user2', 'user3']
data = list(enumerate(users))
print(data) -> [(0, 'user1'), (1, 'user2'), (2, 'user3')]

"""
# //////////////////////////////////////////////////
"""
Файл

1 - Завести переменную, которая будет связана с файлом
2 - Указать путь к файлу
3 - Указать в каком режиме надо работать с файлом
Режимы
а (append) - позволяет дописывать что-то в файл, если такого файла нет, то он его создаст
r (read) - открытие для чтения (если файла нет - выдаст ошибку)
w - позволяет записать данные и создавать файл, если его не существует
    каждый раз перезаписывает данные (если файл существовал, сначала удалит все данные из него, а потом начнет записывать снова)
w+ - позволяет читать читать данные из файла, если файла нет - создаст
r+ - позволяет дописывать что-то в файл для чтения, но если файла нет - выдаст ошибку


● data.close() — используется для закрытия файла, чтобы разорвать подключение файловой переменной с файлом на диске.
● exit() — позволяет не выполнять код, прописанный после этой команды в скрипте.
"""
# colors = ['red', 'green', 'blue']
# data = open('file.txt', 'a') #указываем режим в котором будем работать
# data.writelines(colors) #разделителей не будет
# data.close

# with open('file.txt', 'w') as data:
#     data.write('line 1\n')
#     data.write('line 2\n')

# path = 'file.txt'
# data = open('file.txt', 'r')
# for line in data:
#     print(line)
# data.close()


# file = open("apple.txt", "w", encoding="utf-8")
# file.write("Hello world\n")
# file.write("Hello world\n")
# file.close()

# with open("apple.txt", "a", encoding="utf-8") as file:
#     file.write("cheburek\n")

# with open("apple.txt", "r", encoding="utf-8") as file:
#     stroka = file.readlines()
#     for line in stroka:
#         print(line)
# //////////////////////////////////////////////////
Маруся - 678904958895
Марина - 84578723084
Иван - 746875483084
Иванович - 47358738756
Иванов - 47574897049
Иванченко - 745982394875

"""
Модуль os

Для того, чтобы начать работать с данным модулем необходимо его импортировать в свою программу:
import os

● os.chdir(path) - смена текущей директории. import os
            os.chdir('C:/Users/79190/PycharmProjects/GB')
● os.getcwd() - текущая рабочая директория import os
print(os.getcwd()) # 'C:\Users\79190\PycharmProjects\webproject'

● os.path - является вложенным модулем в модуль os и реализует некоторые полезные функции для работы с путями, такие как:
○ os.path.basename(path) - базовое имя пути 
import os
print(os.path.basename('C:/Users/79190/PycharmProjects/webproject/main.py'))# 'main.py' 

● os.path.abspath(path) - возвращает нормализованный абсолютный путь.
import os
print(os.path.abspath('main.py'))# 'C:/Users/79190/PycharmProjects/webproject/main.py'

"""
# /////////////////////////////////////////////////////////////////////////////
"""
Модуль shutil

Модуль shutil содержит набор функций высокого уровня для обработки файлов, групп файлов, и папок. В частности, доступные здесь функции позволяют копировать, перемещать и удалять файлы и папки. Часто используется вместе с модулем os.
Для того, чтобы начать работать с данным модулем необходимо его импортировать в свою программу: import shutil

● shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst.
● shutil.copy(src, dst) - копирует содержимое файла src в файл или папку dst.
● shutil.rmtree(path) - Удаляет текущую директорию и все поддиректории; path должен указывать на
директорию, а не на символическую ссылку.

"""
